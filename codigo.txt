package mario;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;

class ObstaculoMovil extends Rectangle {
    float velocidad;
    float min, max;
    boolean esHorizontal;

    ObstaculoMovil(int x, int y, int ancho, int alto, float min, float max, float velocidad, boolean esHorizontal) {
        super(x, y, ancho, alto);
        this.min = min;
        this.max = max;
        this.velocidad = velocidad;
        this.esHorizontal = esHorizontal;
    }

    void actualizar() {
        if (esHorizontal) {
            x += velocidad;
            if (x <= min || x >= max) {
                velocidad = -velocidad;
            }
        } else {
            y += velocidad;
            if (y <= min || y >= max) {
                velocidad = -velocidad;
            }
        }
    }
}

class BombaCayendo extends Rectangle {
    float velocidad;
    boolean explotando;
    int radioExplosion;
    int duracionExplosion;
    ImageIcon gifExplosion;

    BombaCayendo(int x, int y, int ancho, int alto, float velocidad) {
        super(x, y, ancho, alto);
        this.velocidad = velocidad;
        this.explotando = false;
        this.radioExplosion = 0;
        this.duracionExplosion = 0;
        this.gifExplosion = new ImageIcon("E:\\mario\\src\\mario\\explosion.gif");
    }

    void actualizar() {
        if (!explotando) {
            y += velocidad;
            // Aumentar la velocidad de caída
            velocidad += 0.2f;
        } else {
            duracionExplosion++;
        }
    }
}

public class JuegoAventuras extends JPanel implements ActionListener, KeyListener {
    static final int ANCHO = 1280;
    private static final int ALTO = 600;
    private static final int ALTURA_SUELO = 230;
    private static final int TAMANIO_JUGADOR = 60;
    private static final int TAMANIO_OBSTACULO = 30;
    private static final int TAMANIO_META = 100;
    private static final float GRAVEDAD = 1f;
    private static final float FUERZA_SALTO = 16f;
    private static final float VELOCIDAD_MAX_X = 7f;
    private static final float ACELERACION_X = 1f;
    private static final float DESACELERACION_X = 1f;
    static final int ANCHO_MAPA = 1600;

    private Timer temporizador;
    private float jugadorX = 0;
    private float jugadorY = ALTO - ALTURA_SUELO - TAMANIO_JUGADOR;
    private float velocidadJugadorX = 0;
    private float velocidadY = 0;
    private boolean saltando = false;
    private int nivel = 3; // Comenzamos directamente en el nivel 3

    private List<Rectangle> obstaculos;
    private Rectangle meta;
    private boolean moviendoIzquierda = false;
    private boolean moviendoDerecha = false;
    private int vidas = 3;
    private boolean juegoGanado = false;
    private boolean juegoTerminado = false;

    private BufferedImage imagenFondo;
    private BufferedImage imagenObstaculo;
    private BufferedImage imagenCorazon;
    private BufferedImage imagenJugadorQuieto;
    private BufferedImage imagenJugadorIzquierda;
    private BufferedImage imagenJugadorDerecha;
    private BufferedImage imagenJugadorSalto;
    private BufferedImage bandera;
    private BufferedImage bomba;
    
    private boolean enRetroceso = false;
    private int duracionRetroceso = 0;
    private static final int DURACION_MAX_RETROCESO = 20;

    private boolean enMenu = false; // Comenzamos directamente en el juego
    private int seleccionMenu = 0;
    private BufferedImage imagenFondoMenu;
    private Font fuentePixel;

    private static final long INTERVALO_GENERACION_BOMBAS = 300; 
    private static final int BOMBAS_POR_GENERACION = 1;
    private static final int DURACION_EXPLOSION = 15; // Duración de la explosión en frames
    private long ultimoTiempoGeneracionBomba = 0;

    public JuegoAventuras() {
        setPreferredSize(new Dimension(ANCHO, ALTO));
        setBackground(Color.BLACK);
        setFocusable(true);
        addKeyListener(this);

        obstaculos = new ArrayList<>();
        inicializarNivel(nivel);

        cargarImagenes();
        cargarFuente();

        temporizador = new Timer(20, this);
        temporizador.start();
    }

    private void cargarImagenes() {
        try {
            imagenFondo = ImageIO.read(new File("E:\\mario\\src\\mario\\fondo.png"));
            imagenObstaculo = ImageIO.read(new File("E:\\mario\\src\\mario\\Bola_pincho.png"));
            imagenCorazon = ImageIO.read(new File("E:\\mario\\src\\mario\\corazon.png"));
            imagenJugadorQuieto = ImageIO.read(new File("E:\\mario\\src\\mario\\personaje.png"));
            imagenJugadorIzquierda = ImageIO.read(new File("E:\\mario\\src\\mario\\izquierda.png"));
            imagenJugadorDerecha = ImageIO.read(new File("E:\\mario\\src\\mario\\derecha.png"));
            imagenJugadorSalto = ImageIO.read(new File("E:\\mario\\src\\mario\\saltar.png"));
            imagenFondoMenu = ImageIO.read(new File("E:\\mario\\src\\mario\\final.png"));
            bandera = ImageIO.read(new File("E:\\mario\\src\\mario\\bandera-final.png"));
            bomba = ImageIO.read(new File("E:\\mario\\src\\mario\\bomba.png"));
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("Error al cargar las imágenes.");
        }
    }

    private void cargarFuente() {
        try {
            InputStream is = getClass().getResourceAsStream("Fuente_retro.ttf");
            fuentePixel = Font.createFont(Font.TRUETYPE_FONT, is).deriveFont(25f);
        } catch (Exception e) {
            e.printStackTrace();
            fuentePixel = new Font("Arial", Font.PLAIN, 40);
        }
    }

    private void inicializarNivel(int nivel) {
        obstaculos.clear();

        switch (nivel) {
            case 1:
                for (int i = 0; i < 6; i++) {
                    obstaculos.add(new Rectangle(400 + i * 200, ALTO - ALTURA_SUELO - 50, 60, 50));
                }
                break;
            case 2:
                int startX = 300;
                int alturaObstaculo = TAMANIO_OBSTACULO;
                int ySuelo = ALTO - ALTURA_SUELO - TAMANIO_OBSTACULO - 55;
                int rango = 50;

                for (int i = 0; i < 10; i++) {
                    obstaculos.add(new ObstaculoMovil(
                        startX + i * (TAMANIO_OBSTACULO + 100),
                        ySuelo - alturaObstaculo,
                        TAMANIO_OBSTACULO,
                        TAMANIO_OBSTACULO,
                        ySuelo - rango,
                        ySuelo + rango,
                        2,
                        false
                    ));
                }
                break;
            case 3:
                // Las bombas se generarán dinámicamente
                break;
        }

        meta = new Rectangle(ANCHO_MAPA - TAMANIO_META, ALTO - ALTURA_SUELO - TAMANIO_META, TAMANIO_META, TAMANIO_META);
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        if (enMenu) {
            pintarMenu(g);
        } else {
            pintarJuego(g);
        }
    }

    private void pintarMenu(Graphics g) {
        if (imagenFondoMenu != null) {
            g.drawImage(imagenFondoMenu, 0, 0, getWidth(), getHeight(), this);
        }

        g.setFont(fuentePixel);
        FontMetrics metrics = g.getFontMetrics(fuentePixel);

        String iniciarTexto = "Iniciar Juego";
        String salirTexto = "Salir";

        int iniciarX = (getWidth() - metrics.stringWidth(iniciarTexto)) / 2;
        int salirX = (getWidth() - metrics.stringWidth(salirTexto)) / 2;

        g.setColor(seleccionMenu == 0 ? new Color(0xff5721) : Color.WHITE);
        g.drawString(iniciarTexto, iniciarX, 400);

        g.setColor(seleccionMenu == 1 ? new Color(0xff5721) : Color.WHITE);
        g.drawString(salirTexto, salirX, 500);
    }

    private void pintarJuego(Graphics g) {
        int desplazamientoMapaX = Math.max(0, Math.min((int) (jugadorX - ANCHO / 2), ANCHO_MAPA - ANCHO));

        if (imagenFondo != null) {
            g.drawImage(imagenFondo, -desplazamientoMapaX, 0, ANCHO_MAPA, ALTO, this);
        } else {
            g.setColor(Color.cyan);
            g.fillRect(0, 0, ANCHO, ALTO);
        }

        BufferedImage imagenJugadorActual;
        if (saltando) {
            imagenJugadorActual = imagenJugadorSalto;
        } else if (moviendoIzquierda) {
            imagenJugadorActual = imagenJugadorIzquierda;
        } else if (moviendoDerecha) {
            imagenJugadorActual = imagenJugadorDerecha;
        } else {
            imagenJugadorActual = imagenJugadorQuieto;
        }

        if (imagenJugadorActual != null) {
            g.drawImage(imagenJugadorActual, (int) (jugadorX - desplazamientoMapaX), (int) jugadorY, TAMANIO_JUGADOR, TAMANIO_JUGADOR, this);
        }

        for (Rectangle obs : obstaculos) {
            if (obs instanceof BombaCayendo) {
                BombaCayendo bomba = (BombaCayendo) obs;
                if (bomba.explotando) {
                    // Dibujar GIF de explosión
                    bomba.gifExplosion.paintIcon(this, g, (int)(bomba.x - bomba.width/2 - desplazamientoMapaX), 
                                                 (int)(bomba.y - bomba.height/2));
                } else {
                    g.drawImage(this.bomba, (int) (bomba.x - desplazamientoMapaX), (int) bomba.y, TAMANIO_OBSTACULO, TAMANIO_OBSTACULO, this);
                }
            } else {
                g.drawImage(imagenObstaculo, (int) (obs.x - desplazamientoMapaX), (int) obs.y, obs.width, obs.height, this);
            }
        }

        if (bandera != null) {
            g.drawImage(bandera, (int) (meta.x - desplazamientoMapaX), (int) meta.y, TAMANIO_META-50, TAMANIO_META, this);
        }

        if (imagenCorazon != null) {
            int tamanioCorazon = 40;
            for (int i = 0; i < vidas; i++) {
                g.drawImage(imagenCorazon, ANCHO - (i + 1) * (tamanioCorazon + 5), 10, tamanioCorazon, tamanioCorazon, this);
            }
        }

        if (juegoGanado) {
            g.setColor(Color.black);
            g.drawString("¡Ganaste! Presiona 'R' para reiniciar.", ANCHO / 2 - 150, ALTO / 2);
        } else if (juegoTerminado) {
            g.setColor(Color.black);
            g.drawString("Juego Terminado. Presiona 'R' para reiniciar.", ANCHO / 2 - 150, ALTO / 2);
        }
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (enMenu || juegoGanado || juegoTerminado) return;

        if (enRetroceso) {
            duracionRetroceso--;
            if (duracionRetroceso <= 0) {
                enRetroceso = false;
            }
        }

        velocidadY += GRAVEDAD;
        jugadorY += velocidadY;

        if (jugadorY >= ALTO - ALTURA_SUELO - TAMANIO_JUGADOR) {
            jugadorY = ALTO - ALTURA_SUELO - TAMANIO_JUGADOR;
            velocidadY = 0;
            saltando = false;
        }

        if (moviendoIzquierda) {
            velocidadJugadorX -= ACELERACION_X;
        } else if (moviendoDerecha) {
            velocidadJugadorX += ACELERACION_X;
        } else {
            if (velocidadJugadorX > 0) {
                velocidadJugadorX = Math.max(0, velocidadJugadorX - DESACELERACION_X);
            } else if (velocidadJugadorX < 0) {
                velocidadJugadorX = Math.min(0, velocidadJugadorX + DESACELERACION_X);
            }
        }

        velocidadJugadorX = Math.max(-VELOCIDAD_MAX_X, Math.min(VELOCIDAD_MAX_X, velocidadJugadorX));
        jugadorX += velocidadJugadorX;

        for (Rectangle obs : obstaculos) {
            if (obs instanceof ObstaculoMovil) {
                ((ObstaculoMovil) obs).actualizar();
            }
        }

        if (nivel == 3) {
            generarBombas();
            actualizarBombas();
        }

        verificarColisiones();

        if (jugadorX + TAMANIO_JUGADOR > meta.x && jugadorX < meta.x + TAMANIO_META &&
            jugadorY + TAMANIO_JUGADOR > meta.y && jugadorY < meta.y + TAMANIO_META) {
            juegoGanado = true;
            temporizador.stop();
        }

        if (vidas <= 0) {
            juegoTerminado = true;
            temporizador.stop();
        }

        repaint();
    }

    private void generarBombas() {
        long tiempoActual = System.currentTimeMillis();
        if (tiempoActual - ultimoTiempoGeneracionBomba >= INTERVALO_GENERACION_BOMBAS) {
            int x = (int) (Math.random() * (ANCHO - TAMANIO_OBSTACULO));
            obstaculos.add(new BombaCayendo(x, 0, TAMANIO_OBSTACULO, TAMANIO_OBSTACULO, 2f));
            ultimoTiempoGeneracionBomba = tiempoActual;
        }
    }

    private void actualizarBombas() {
        Iterator<Rectangle> iterador = obstaculos.iterator();
        while (iterador.hasNext()) {
            Rectangle obs = iterador.next();
            if (obs instanceof BombaCayendo) {
                BombaCayendo bomba = (BombaCayendo) obs;
                bomba.actualizar();
                if (bomba.y >= ALTO - ALTURA_SUELO - bomba.height && !bomba.explotando) {
                    bomba.explotando = true;
                    bomba.radioExplosion = 0;
                    bomba.duracionExplosion = 0;
                    // Reposicionar la bomba para centrar la explosión
                    bomba.y = ALTO - ALTURA_SUELO - bomba.height;
                    bomba.x -= bomba.width / 2;
                } else if (bomba.explotando && bomba.duracionExplosion >= DURACION_EXPLOSION) {
                    iterador.remove();
                }
            }
        }
    }

    private void verificarColisiones() {
        Rectangle rectJugador = new Rectangle((int) jugadorX, (int) jugadorY, TAMANIO_JUGADOR, TAMANIO_JUGADOR);

        for (Rectangle obs : obstaculos) {
            Rectangle rectObs = new Rectangle((int) obs.x, (int) obs.y, obs.width, obs.height);

            if (rectJugador.intersects(rectObs)) {
                if (obs instanceof BombaCayendo) {
                    BombaCayendo bomba = (BombaCayendo) obs;
                    if (!bomba.explotando) {
                        bomba.explotando = true;
                        bomba.radioExplosion = 0;
                        bomba.duracionExplosion = 0;
                    }
                }

                if (nivel == 2 || (obs instanceof BombaCayendo && ((BombaCayendo) obs).explotando)) {
                    vidas--;
                    iniciarRetroceso();
                    break;
                }
                
                if (velocidadY > 0 && jugadorY + TAMANIO_JUGADOR > obs.y && jugadorY < obs.y + obs.height) {
                    jugadorY = obs.y - TAMANIO_JUGADOR;
                    velocidadY = -FUERZA_SALTO * 0.5f;
                    vidas--;
                } else if (velocidadY < 0 && jugadorY < obs.y + obs.height && jugadorY + TAMANIO_JUGADOR > obs.y) {
                    jugadorY = obs.y + obs.height;
                    velocidadY = 0;
                    vidas--;
                } else if (velocidadJugadorX != 0) {
                    if (velocidadJugadorX > 0) {
                        jugadorX = obs.x - TAMANIO_JUGADOR;
                    } else {
                        jugadorX = obs.x + obs.width;
                    }
                    velocidadJugadorX = 0;
                    vidas--;
                }
                
                iniciarRetroceso();
                break;
            }
        }
    }
    
    private void iniciarRetroceso() {
        enRetroceso = true;
        duracionRetroceso = DURACION_MAX_RETROCESO;
    }

    @Override
    public void keyPressed(KeyEvent e) {
        int codigoTecla = e.getKeyCode();
        if (enMenu) {
            manejarTeclaPresionadaMenu(codigoTecla);
        } else {
            manejarTeclaPresionadaJuego(codigoTecla);
        }
    }

    private void manejarTeclaPresionadaMenu(int codigoTecla) {
        if (codigoTecla == KeyEvent.VK_UP) {
            seleccionMenu = (seleccionMenu == 0) ? 1 : 0;
            repaint();
        } else if (codigoTecla == KeyEvent.VK_DOWN) {
            seleccionMenu = (seleccionMenu == 1) ? 0 : 1;
            repaint();
        } else if (codigoTecla == KeyEvent.VK_ENTER) {
            if (seleccionMenu == 0) {
                enMenu = false;
                reiniciarJuego();
            } else if (seleccionMenu == 1) {
                System.exit(0);
            }
        }
    }

    private void manejarTeclaPresionadaJuego(int codigoTecla) {
        if (codigoTecla == KeyEvent.VK_LEFT) {
            moviendoIzquierda = true;
        } else if (codigoTecla == KeyEvent.VK_RIGHT) {
            moviendoDerecha = true;
        } else if (codigoTecla == KeyEvent.VK_UP && !saltando && jugadorY == ALTO - ALTURA_SUELO - TAMANIO_JUGADOR) {
            saltando = true;
            velocidadY = -FUERZA_SALTO;
        } else if (codigoTecla == KeyEvent.VK_R && (juegoTerminado || juegoGanado)) {
            reiniciarJuego();
        }
    }

    private void reiniciarJuego() {
        nivel = 1;
        vidas = 3;
        juegoGanado = false;
        juegoTerminado = false;
        inicializarNivel(nivel);
        jugadorX = 0;
        jugadorY = ALTO - ALTURA_SUELO - TAMANIO_JUGADOR;
        velocidadJugadorX = 0;
        velocidadY = 0;
        saltando = false;
        enRetroceso = false;
        duracionRetroceso = 0;
        temporizador.start();
    }

    @Override
    public void keyReleased(KeyEvent e) {
        int codigoTecla = e.getKeyCode();
        if (codigoTecla == KeyEvent.VK_LEFT) {
            moviendoIzquierda = false;
        } else if (codigoTecla == KeyEvent.VK_RIGHT) {
            moviendoDerecha = false;
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {
        // No se necesita implementar para este juego
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("Juego de Aventuras");
            JuegoAventuras juego = new JuegoAventuras();
            frame.add(juego);
            frame.pack();
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
        });
    }
}